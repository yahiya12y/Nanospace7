<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>J.A.R.V.I.S. Core Interface</title>
    <style>
        :root { --glow: #00e5ff; --bg: rgba(0, 20, 30, 0.85); }
        body { margin: 0; background: #000; color: var(--glow); font-family: 'Orbitron', sans-serif; overflow: hidden; }
        
        /* HUD UI */
        #hud { position: absolute; inset: 0; pointer-events: none; border: 1px solid rgba(0, 229, 255, 0.3); margin: 15px; z-index: 10; }
        .glass { 
            position: absolute; top: 40px; left: 40px; width: 320px; padding: 25px;
            background: var(--bg); backdrop-filter: blur(15px); border-radius: 2px;
            border-left: 4px solid var(--glow); pointer-events: auto;
        }
        
        button { 
            background: transparent; border: 1px solid var(--glow); color: var(--glow);
            padding: 12px; width: 100%; cursor: pointer; letter-spacing: 3px; font-weight: bold;
            transition: all 0.3s;
        }
        button:hover { background: var(--glow); color: #000; box-shadow: 0 0 20px var(--glow); }

        #cam-view { position: absolute; bottom: 40px; right: 40px; width: 240px; border: 1px solid var(--glow); transform: scaleX(-1); opacity: 0.4; }
        .data-stream { font-size: 10px; margin-top: 15px; opacity: 0.7; font-family: monospace; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="hud">
        <div class="glass">
            <h1 style="margin: 0; font-size: 18px;">MARK VII ENGINE</h1>
            <div id="log" style="font-size: 12px; margin: 10px 0;">SYSTEM: STANDBY</div>
            <button id="power-btn">ENGAGE SYSTEM</button>
            <div class="data-stream">
                > CONNECTING NEURAL LINK...<br>
                > CALIBRATING OPTICAL SENSORS...<br>
                <span id="pinch-val">FORCE: 0.00</span>
            </div>
        </div>
    </div>

    <video id="cam-view" autoplay></video>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" }}
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { Hands } from 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js';
        import { Camera } from 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js';

        let scene, camera, renderer, composer, particles, material;
        let pinchFactor = 0;

        // --- System Init ---
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            composer.addPass(bloom);

            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(3000 * 3);
            for(let i=0; i<9000; i++) pos[i] = (Math.random()-0.5) * 60;
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));

            material = new THREE.ShaderMaterial({
                uniforms: { uTime: {value: 0}, uPinch: {value: 0} },
                vertexShader: `
                    uniform float uTime; uniform float uPinch;
                    void main() {
                        vec3 p = position;
                        // VORTEX EFFECT: Suck particles to center as uPinch increases
                        float dist = length(p);
                        p = mix(p, vec3(0.0), uPinch * (1.0 - dist/50.0));
                        p.x += sin(uTime + p.y*0.1) * 2.0;
                        vec4 mvp = modelViewMatrix * vec4(p, 1.0);
                        gl_PointSize = (12.0 / -mvp.z);
                        gl_Position = projectionMatrix * mvp;
                    }
                `,
                fragmentShader: `
                    void main() {
                        float r = distance(gl_PointCoord, vec2(0.5));
                        if(r > 0.5) discard;
                        gl_FragColor = vec4(0.0, 0.9, 1.0, 1.0 - r*2.0);
                    }
                `,
                transparent: true, blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geo, material);
            scene.add(particles);
            animate();
        }

        async function engage() {
            const log = document.getElementById('log');
            log.innerText = "REQUESTING ENCRYPTION...";
            
            try {
                const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
                hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
                
                hands.onResults((res) => {
                    if (res.multiHandLandmarks && res.multiHandLandmarks[0]) {
                        log.innerText = "SYSTEM: LINK ACTIVE";
                        const h = res.multiHandLandmarks[0];
                        const d = Math.hypot(h[4].x - h[8].x, h[4].y - h[8].y);
                        // Pinch Logic: Close fingers = Vortex Collapse
                        pinchFactor = THREE.MathUtils.lerp(pinchFactor, d < 0.05 ? 1.0 : 0.0, 0.1);
                        material.uniforms.uPinch.value = pinchFactor;
                        document.getElementById('pinch-val').innerText = `FORCE: ${pinchFactor.toFixed(2)}`;
                        
                        particles.rotation.y = (h[9].x - 0.5) * 3;
                        particles.rotation.x = (h[9].y - 0.5) * 3;
                    } else {
                        log.innerText = "SYSTEM: SEARCHING...";
                    }
                });

                const cam = new Camera(document.getElementById('cam-view'), {
                    onFrame: async () => { await hands.send({image: document.getElementById('cam-view')}); },
                    width: 640, height: 480
                });
                await cam.start();
                document.getElementById('power-btn').style.display = 'none';
            } catch (e) {
                log.innerText = "ERROR: ACCESS DENIED";
                alert("Please run this via 'Live Server' or HTTPS to allow camera access.");
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.uTime.value += 0.02;
            composer.render();
        }

        document.getElementById('power-btn').onclick = engage;
        initThree();
    </script>
</body>
</html>
